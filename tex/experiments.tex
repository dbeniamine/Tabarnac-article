%!TEX encoding=UTF-8 Unicode
%!TEX root=../tabarnac.tex

\section{Methodology of the Evaluation}
\label{sec:metho}

This section briefly discusses our evaluation methodology of \TABARNAC.
We present the hardware architecture and the applications that wil be used in the analysis.

\subsection{Hardware Environment}
\label{sec:expe-setup}

\begin{table}[!b]
    \centering
    \caption{Hardware configuration of our evaluation system.}
    \label{tab:turing}
    \footnotesize
        \begin{tabular}{lccccc}
            \toprule
            \multirow{2}{1.5cm}{System total} & Nodes & Threads & Freq (GHz) & Memory (Gib) \\
            \cmidrule(lr){2-5}
                & $4$   & $64$ & $2.00$ & $128$ \\
            \midrule
           \multirow{2}{1.5cm}{\vspace{2mm}Per NUMA node} & Cores & Threads & L3 Cache (Mib) & Memory (GiB) \\
           \cmidrule(lr){2-5}
            & $8$ & $16$ & $18$ & $32$  \\
            \bottomrule
        \end{tabular}

\end{table}

All experiments were run on a NUMA machine, which is composed of $4$ Intel Xeon X7550
processors (Nehalem microarchitecture~\cite{Intel2010}). Each processor has its own memory controller and therefore forms a NUMA node. The hardware details are summarized in Table~\ref{tab:turing}.
The machine is running \texttt{Ubuntu 12.04.5 LTS} with a Linux kernel, version 3.13.0-48.
\DB{Other thing to mention, numactl version, gcc 4.6.3}

For the plots representing speedups, each configuration was executed between 10 and 30
times. Each point represents the arithmetic mean of all runs.
\itodo{stddev}

\subsection{Applications}

We evaluate the following applications with \TABARNAC: a \emph{matrix multiplication}, the \emph{IS} benchmark and \emph{Ondes3D}.
They were chosen to demonstrate different memory access behaviors and ways to improve them.

The \emph{matrix multiplication} is a well-known algorithm that is used to verify the accuracy of \TABARNAC, as well as to discuss the performance improvements that can be achieved.
\emph{IS} is a benchmark from the OpenMP implementation of the NAS Parallel Benchmark suite~(NPB)~\cite{Jin1999}. IS sorts a set of integer numbers using a bucket sort algorithm.
\emph{Ondes3D} is the main numerical kernel of the Ondes3D application~\cite{Dupros2008}. It simulates the propagation of seismic waves using a finite-differences numerical method.

All applications were compiled with \texttt{gcc}, version 4.6.3, with the \texttt{-O2} optimization flag.
Due to space restrictions, we show the characterization of the applications
with 4 threads.  The performance evaluation is performed with 64 threads,
which is the maximum number of threads that our evaluation machine can execute
in parallel.  The \emph{matrix multiplication} performance were evaluated on
matrix of size $4096*4096$ doubles ($12.8$Mib per matrix). \emph{IS} was run
in class D resulting on a memory usage of $33.5$Gib, Finally Ondes3D has a memory
usage of $11.3$Gib.

\section{Analysis and Performance Results}
\label{sec:expe-analysis}

This section presents the results of our analysis with \TABARNAC.
For each application, we show the memory access behavior, discuss strategies to optimize this behavior and present the performance improvements that can be achieved.

% In this section, we analyze several benchmarks using \TABARNAC, we discuss
% their memory access distribution. Using this analysis we propose some
% optimizations and we evaluate them by comparing it to automatic data mapping
% tools.

\subsection{Matrix Multiplication}
\label{sec:exp-mat}

The first benchmark presented is based on a naive matrix multiplication
computing $C=A \times B$. Our aim here is not to provide a kernel competing with the
state of the art, but to show how \TABARNAC can help to improve such
applications. We compare two implementations of the matrix multiplication, in
the first one, called \emph{Naive}, each threads start by computing
$C[0][tid]$ and then jumps $N$ elements after in the matrix, where $N$ is the
number of threads. Although this implementation is known to be bad, comparing
how much it's accelerated by the best mechanism to the acceleration of a
better version to understand the importance of the quality of the original
code. Moreover when an application have such a bad memory access pattern, it
is not always possible to change completely the pattern, therefore, it is
interesting to discuss the improvement we can obtain on this kernel without
modifying the algorithm. The second implementation uses a non recursive bloc
decomposition.

The figures presented in this sections are part of the \TABARNAC visualization.
Each plot show for a particular data structure the number of memory accesses
per page and per threads. Only structures \texttt{B} and \texttt{C} are
presented as for both algorithm \texttt{A} have more are less the same access
pattern than \texttt{C}.

\begin{figure}[htb]
    \centering
    \subfigure[Structure B (naive)]{
        \includegraphics[height=.27\textheight] {mat_B_modulo}
        \label{fig:matrix-B-naive}
    }
    \subfigure[Structure C (naive)]{
        \includegraphics[height=.27\textheight] {mat_C_modulo}
        \label{fig:matrix-C-naive}
    }
    \caption{By thread access distribution on data structures A and B for the
        naive matrix multiplication. Each plots shows the number of access
    depending on the page number (inside the structure) for each thread.}
    \label{fig:matrix-naive}
\end{figure}

For the naive matrix multiplication, as we can see in
\ref{fig:matrix-naive}, all the pages of both structures are used by every
thread. Therefore, when we execute this code on a NUMA machine, wherever we
map the page, all the nodes but one will trigger remote memory accesses. We
can improve there are several ways to improve this behavior: an easy solution
is to tell the operating system to interleave pages through the different
nodes. This will result on a better balance of memory bandwidth between the
nodes. An other solution is to create local copies of \texttt{A} and
\texttt{B} on each node as these matrix are only read. Finally we can modify
the algorithm to improve the locality, which mean using the bloc algorithm.

\begin{figure}[htb]
    \centering
    \subfigure[Structure B (bloc)]{
        \includegraphics[height=.27\textheight] {mat_B_bloc}
        \label{fig:matrix-B-bloc}
    }
    \subfigure[Structure C (bloc)]{
        \includegraphics[height=.27\textheight] {mat_C_bloc}
        \label{fig:matrix-C-bloc}
    }
    \caption{By thread access distribution on data structures A and B for the
    bloc matrix multiplication.}
    \label{fig:matrix-bloc}
\end{figure}

As we can see in figure \ref{fig:matrix-bloc}, the bloc algorithm improve the page
locality compared to the naive one. In our algorithm, structures \texttt{B}
and \texttt{C} are not divided the same way, resulting in two different
patterns. For structure \texttt{B} (fig \ref{fig:matrix-B-bloc}), the pages
are interleave, threads $T0$ and $T1$ works on the same pages while threads
$T2$ and $T3$ works on another set of pages. Structures \texttt{C} (and
\texttt{A}, fig \ref{fig:matrix-C-bloc}) are cut in two parts, the first half
is shared by thread $T0$ and $T2$ while the two others works on the second
half. This behavior provides strong page exclusivity and is therefore more
suitable for NUMA machines. We can easily put each subpart of \texttt{C} (and
\texttt{A}) on a NUMA node and map the thread using it to this node, matrix
\texttt{B} can be distributed using interleave policy.

To test the efficiency of the proposed modification, we compare the execution
time of our modified code (\TABARNAC) to the original code, running without any
improvements (base) and the same code executed with NUMA balancing enable in the
kernel (NUMA Balancing)~\cite{Corbet}.
\DB{ugly, rewrite needed}

\begin{figure}[htb]
    \centering
    \includegraphics[width=.8\linewidth]{mat_time}
    \caption{Execution time of the matrix multiplication for size $4096\times 4096$ doubles.}
    \label{fig:matrix-res}
\end{figure}

Figure \ref{fig:matrix-res} show the experimental results, we can see that for
the naive algorithm, NUMA Balancing is already efficient and results in $40\%$
speedup. Still using the interleave policy avoid the runtime overhead, and
allow us to obtain almost $50\%$ speedup. For the bloc version, all runtimes
provide the same execution time as this algorithm is designed to fit in the
cache.

Although this example is more a school case than a real experiment it shows
how \TABARNAC can help improving an application by highlighting inefficient
memory access behaviors. This knowledge can be used two different ways, and always
results on significant improvement: either you can do some algorithmic
modification (here going from the naive to the bloc version), or at least you
can choose the best NUMA page mapping policy.

\subsection{IS}
\label{sec:exp-is}

According the NAS parallel benchmark
website\footnote{\url{http://www.nas.nasa.gov/publications/npb.html}, visited
2015-04-25} it has a random memory access. Thus it is a good candidate to be
optimized using \TABARNAC.

\begin{figure}[htb]
    \centering

    \subfigure[\texttt{key\_buff2}]{
        \includegraphics[height=.27\textheight]  {is_w_kb2_orig}
        \label{fig:is-behaviour-orig-kb2}
    }
    \subfigure[\texttt{key\_array}]{
        \includegraphics[height=.27\textheight]  {is_w_kba_orig}
        \label{fig:is-behaviour-orig-kba}
    }
    \subfigure[\texttt{key\_buff1}]{
        \includegraphics[height=.27\textheight]  {is_w_kb1_orig}
        \label{fig:is-behaviour-orig-kb1}
    }
    \caption{Original memory access distribution for the main structure of
        \emph{IS} with $4$ threads.}
    \label{fig:is-behaviour-orig}
\end{figure}

Figure \ref{fig:is-behaviour-orig} shows the access distributions for the
three main structures of \emph{IS} class W with $4$ threads. We can see that
each of these structures have a different access pattern: \texttt{key\_array}
(fig \ref{fig:is-behaviour-orig-kba}) access distribution shows that every
threads works on a different part of the structures which allows automated
tools to do efficient data/thread mapping on it. However \texttt{key\_buff2}
(fig \ref{fig:is-behaviour-orig-kb2}) is completely shared by every threads,
but the most interesting access distribution is the one of \texttt{key\_buff1}
(fig \ref{fig:is-behaviour-orig-kb1}). Indeed the access repartition seems to
follow a nice Gaussian, which means a few pages are more used than all the
others. With such a distribution, automated tools might generate a lot of page
migration.

\lstinputlisting[caption=\emph{IS} code responsible for the
Gaussian distribution of memory accesses, label=lst:is]{code/is.c}

Using this knowledge, we can look at \emph{IS} code and identify the source of the
Gaussian pattern, indeed all the access to \texttt{key\_buff1} are linear
excepts the one shown in listing \ref{lst:is}\footnote{
    The code has been slightly modified to make it more readable. In the
    original version, the arrays \texttt{key\_buff1} (resp \texttt{key\_buff2})
    are accessed via a generic pointer called \texttt{key\_buff\_ptr} (resp
    \texttt{key\_buff\_ptr2}). More over some comments have been removed as
    they are not necessary here.
}  line \ref{lst:is-gaus}-\ref{lst:is-gaus-end} which depends on the values of
\texttt{key\_buff2}. The comments above the OpenMp loop explains that the
cyclic distribution will result in an unbalanced work distribution. Still we can easily design a cyclic
distribution aware of the Gaussian pattern which provides both a good
distribution of access among the thread and a strong locality. The idea is to
split the loop in two half and give one part of each half to each threads in a
round robin way. We can do that only by modifying line \ref{lst:is-cyclic} as
shown in listing \ref{lst:is-modif}.
\begin{lstlisting}[caption=Optimization for \emph{IS}., label=lst:is-modif]
#pragma omp for schedule(static,NUM_BUCKETS/(2*omp_get_max_threads()))
\end{lstlisting}

\begin{figure}[htb]
    \centering

    \subfigure[The \texttt{key\_buff2} structure.]{
        \includegraphics[height=.27\textheight] {is_w_kb2_modif}
        \label{fig:is-behaviour-modif-kb2}
    }
    \subfigure[The \texttt{key\_array} structure.]{
        \includegraphics[height=.27\textheight] {is_w_kba_modif}
        \label{fig:is-behaviour-modif-kba}
    }

    \subfigure[The \texttt{key\_buff1} structure.]{
        \includegraphics[height=.27\textheight] {is_w_kb1_modif}
        \label{fig:is-behaviour-modif-kb1}
    }
    \caption{Memory access distribution for the main structure of
        \emph{IS} with $4$ threads after our modifications.}
    \label{fig:is-behaviour-modif}
\end{figure}

With this extremely simple code modification we obtain the access distribution
shown in figure \ref{fig:is-behaviour-modif}. We can see that the Gaussian
access of \texttt{key\_buff1} is now distributed over the threads. Each page
of this structure is almost used by only one thread. Moreover
\texttt{key\_buff2} access distribution have also changed, we can see that
each thread uses mostly one part of the array.

The main point of our code modification is to improve the affinity between
thread and memory, therefore we need to pin each thread on a core to keep them
near to their data. To do so we use \texttt{GOMP\_CPU\_AFFINITY}. \TABARNAC
also shows us that the first touch is always done by the thread actually using
the data for IS, therefore we do not need to map the data on NUMA nodes.

We then compare the execution time of \emph{IS.D} for the three scheduling
methods \emph{Dynamic}, \emph{Cyclic} with a step of $1$ and \TABARNAC:
cyclic with the distribution proposed. For the two first methods we compare the
execution time on the bare operation system  (Base), the execution time with
interleave policy (Interleave) and with NUMA balancing enabled in the kernel
(NUMA Balancing). Interleave and NUMA Balancing are not relevant with
\TABARNAC modifications.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=.9\linewidth]{is_exectime}
    \caption{Speedup for \emph{IS} in class D compared to the baseline.}
\label{fig:is-res}
\end{figure}

Figure\ref{fig:is-res} show the speedup of \emph{IS} in class D compared to
the default version (\emph{dynamic}) for each scheduling method, and for each
optimization technique. The first thing to notice is that with the
\emph{dynamic} scheduling, both Interleave and NUMA Balancing slows
the application down. Indeed simple optimization policy are hardly efficient
for non NUMA conscious code.

The cyclic policy, proposed in the original code already provides up to $13\%$
speedup, while the developers clearly explain that it should be slower than
dynamic. We can see that both interleave and NUMA Balancing are not suitable
for this method.

The \TABARNAC version provides more than $20\%$ speedup with very small code
modification (two lines of code an \texttt{export} for the thread affinity.
This example shows how analyzing an application's memory behavior can lead to
significant execution time improvement where automated tools were only slowing
the application down.

\subsection{Ondes3D}
\label{sec:exp-ondes3d}

\begin{figure}[htb]
    \centering

    \subfigure[Access distribution for \texttt{fz}.]{
        \includegraphics[height=.27\textheight] {ondes3d_fz_dist_orig}
        \label{fig:ondes3d-behaviour-fz-orig}
    }
    \subfigure[First-touch \texttt{fz}.]{
        \includegraphics[height=.27\textheight] {ondes3d_fz_ft_orig}
        \label{fig:ondes3d-ft-fz-orig}
    }
    \caption{Original access and first-touch distribution for structure
        \texttt{fz} from \emph{Ondes3D}.}
    \label{fig:ondes3d-orig}
\end{figure}

The analysis of \emph{Ondes3D} access distributions shows that each
structures, as we can see for structure \texttt{fz} in figure
\ref{fig:ondes3d-behaviour-fz-orig}, is well divided between the threads.
Still we can notice that thread $T0$ seems to access the whole structure. If
we look at the first touch distribution (fig \ref{fig:ondes3d-ft-fz-orig}), we
remark that indeed this thread is responsible for all first access. Due to
this pattern, if we run \emph{Onde3d} without doing any mapping, every page
will be mapped on node $0$ resulting on many remote access. An easy fix is to
do the initialization in parallel and to pin each thread on a different core.

\begin{figure}[htb]
    \centering

    \subfigure[Access distribution for \texttt{fz}.]{
        \includegraphics[height=.27\textheight] {ondes3d_fz_dist_modif}
        \label{fig:ondes3d-behaviour-fz-modif}
    }
    \subfigure[First-touch \texttt{fz}.]{
        \includegraphics[height=.27\textheight] {ondes3d_fz_ft_modif}
        \label{fig:ondes3d-ft-fz-modif}
    }
    \caption{Access and first-touch distribution  for structure
        \texttt{fz} from \emph{Ondes3D}, after modifications.}
    \label{fig:ondes3d-modif}
\end{figure}

Such Modifications results on the access distribution of figure
\ref{fig:ondes3d-behaviour-fz-modif}, we can see that now $T0$  access only
its own portion of the structure. Moreover as expected, figure
\ref{fig:ondes3d-ft-fz-modif} shows that the first touch is now distributed
over the structures and match the actual access distribution.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=.7\linewidth]{ondes3d_exectime}
    \caption{Speedup for \emph{Ondes3D} compared to the original application.}
\label{fig:ondes-res}
\end{figure}

Finally, we evaluate the modified version by comparing it with the original
version run on the normal OS, with Numa Balancing activated and with
interleave policy. Figure \ref{fig:ondes-res} present the results of this
evaluation, we can see that every method improve the execution time, still
\emph{Numa Balancing} provides less than $30\%$ speedup while static mapping
(Interleave or modified code) allows us to get almost $60\%$ speedup. This is
due to the training time described in section \ref{sec:soa-mapping}. Indeed
with \emph{Numa Balancing}, every pages are initially mapped by the OS they
are only moved a while later, after many remote access occurred. This is a
pathological case where static mapping is to be preferred against automated
tools.  \emph{Interleave policy} provides almost the same speedup as
\TABARNAC~ as it distribute the pages over the NUMA nodes at the beginning of
the execution. Nevertheless the interleave version only maps the data no the
threads, therefore if the performances might drop if the OS does not map them
``correctly'' while the modified version propose a thread mapping ensuring
data locality.
