%!TEX encoding=UTF-8 Unicode
%!TEX root=../tabarnac.tex

\section{Conclusions and Future Work}
\label{sec:concl}

In this paper, we presented \TABARNAC, a new tool to trace, analyze and
optimize the memory behavior of parallel applications running on NUMA
machines. \TABARNAC is divided into two parts: the first is a memory tracer
based on the Pin dynamic binary instrumentation. It records the
number of reads and writes done by all threads for each page.
The advantage of instrumentation is that it is the most
accurate and portable way to generate memory traces.
Despite the overhead caused by the instrumentation, our tool is efficient enough to analyze even huge applications in a reasonable time.

Presenting memory traces in an intuitive way is a challenge, to address it, we
choose to provide a summary of the trace in the form of an HTML page
interleaving text and plots. This HTML page is generate by a R-markdown
script. It starts with a general explanation on NUMA machines and classical
inefficient behavior, than it shows several plots providing different
interpretations of the trace. Each plots is preceded by explanations on how to
read it, what kind of issues it can help to identify and how to solve them.

Using \TABARNAC, we analyzed three parallel applications. The first is a
matrix multiplication and is useful to discuss classical well known memory access issues.
Then we analyzed \emph{IS} from the NAS Parallel Benchmarks. Finally, we studied
\emph{Ondes3D}, a real life application that simulates seismic waves. For all
these applications, \TABARNAC helped us understanding their performance issues.
Using this knowledge, we proposed code modification to optimize the behavior, resulting in
significant speedups compared to the original version (up to $60\%$ speedup),
and to the results provided by automated tools (more than $10\%$ speedup).

Future work will focus on two directions. First, we will improve the
structure detection support to be able to analyze Fortran programs, as many
scientific applications are written in Fortran. Second, we will work
on automatic detection of ``bad'' memory behavior, such as an all-to-all sharing,
to make the analysis even more useful.
